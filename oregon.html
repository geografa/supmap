<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Slipways in OR</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
<script src="https://api.mapbox.com/mapbox-gl-js/v1.11.1/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v1.11.1/mapbox-gl.css" rel="stylesheet" />

<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.5.1/mapbox-gl-geocoder.min.js"></script>
<link
rel="stylesheet"
href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.5.1/mapbox-gl-geocoder.css"
type="text/css"
/>
<!-- Promise polyfill script required to use Mapbox GL Geocoder in IE 11 -->
<script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.min.js"></script>

<link rel="stylesheet" href="styles.css" type="text/css" />

<style>
	body { margin: 0; padding: 0; }
  #map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>
<body>
<div id="map"></div>
<div id="globe"><a href="#"><img src="./img/globe.png" alt="zoom to full"></a></div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoiZ3JhZmEiLCJhIjoiY2ptYjNtZWxnMDBrdDNwbnVicGJzOWg2NyJ9.9OulyCe3kEqMAXPbx1mKUA';
var map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/grafa/ckd6dcazo00l01is4jrzlodal',
    center: [-119.655,44.268],
    zoom: 6.5,
    hash: true
});

// add geocoder
map.addControl(
    new MapboxGeocoder({
        accessToken: mapboxgl.accessToken,
        mapboxgl: mapboxgl,
        marker: false,
        localGeocoder: forwardGeocoder,
        placeholder: "e.g Willamette Park"
    })
);

// Add geolocate control to the map.
map.addControl(new mapboxgl.GeolocateControl({
    positionOptions: {
        enableHighAccuracy: true
    },
    trackUserLocation: false
}), 'top-right');


function forwardGeocoder(query) {
  var launches = map.querySourceFeatures('osmw-launches', {
    sourceLayer: 'osmw-launches'
  });

  if (launches) {
    // only list unique features from vector tiles
    var uniqueFeatures = getUniqueFeatures(launches, "FACILNM");
    var matchingFeatures = [];
    for (i=0; i<uniqueFeatures.length; i++){
      var feature = uniqueFeatures[i]
      query.toLowerCase();
      if (feature.properties.FACILNM && feature.properties.FACILNM.toLowerCase().search(query.toLowerCase()) !== -1) {
        feature['place_name']= '🏄‍♀️ ' + feature.properties.FACILNM
        feature['center'] = feature.geometry.coordinates
        matchingFeatures.push(feature);
      }
    }
    return matchingFeatures;
  }
};

function getUniqueFeatures(array, comparatorProperty) {
    var existingFeatureKeys = {};
    // Because features come from tiled vector data, feature geometries may be split
    // or duplicated across tile boundaries and, as a result, features may appear
    // multiple times in query results.
    var uniqueFeatures = array.filter(function(el) {
        if (existingFeatureKeys[el.properties[comparatorProperty]]) {
            return false;
        } else {
            existingFeatureKeys[el.properties[comparatorProperty]] = true;
            return true;
        }
    });
    return uniqueFeatures;
}

map.on('load', function() {
    map.addSource('osmw-launches', {
        type: 'vector',
        url: 'mapbox://grafa.osmw-launches'
    });

    map.addLayer({
        id: 'osmw-launches',
        source: 'osmw-launches',
        'source-layer': 'osmw-launches',
        type: 'symbol',
        layout: {
            // Set the label content to the
            // feature's `name` property
            // text-field: ['get', 'name'],
            'icon-image': [
                "step",
                ["zoom"],
                "dot-blue",
                13,
                "slipway-15",
                22,
                "slipway-15"
                ],
            'icon-size': [
                'interpolate', ['linear'], ['zoom'],
                0, 0.3,
                11, 0.5,
                15, 1
            ],
            'icon-allow-overlap': true
        },
    });

    // When a click event occurs on a feature in the places layer, open a popup at the
    // location of the feature, with description HTML from its properties.
    map.on('click', 'osmw-launches', function(e) {
        let coordinates = e.features[0].geometry.coordinates.slice();
        let props = e.features[0].properties;
        let launchName = props.FACILNM,
            launchPhoto = props.PHOTOURL,
            launchFacilType = props.FACILTYPE,
            launchRampType = props.FACILTYPE,
            launchUseFee = props.USEFEE;

            osmNode  = e.features[0].properties['@id'];
            description = (launchPhoto) ? '<h2>' + launchName + '</h2><img src=" '+ launchPhoto +' " /><br>' +
                              'Facility type: ' + launchFacilType + '<br>' + 
                              'Use fee: ' + launchUseFee + '<br>' + 
                              '🚗 <a href="javascript:void(0)" onclick="getLocation(getRoute)";return false;>Directions</a>': 
                              '<h2>' + launchName + '</h2>' +
                              'Facility type: ' + launchFacilType + '<br>' + 
                              'Use fee: ' + launchUseFee + '<br>' + 
                              '🚗 <a href="javascript:void(0)" onclick="getLocation(getRoute)";return false;>Directions</a>';

        // Ensure that if the map is zoomed out such that multiple
        // copies of the feature are visible, the popup appears
        // over the copy being pointed to.
        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
            coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
        }
        popup
            .setLngLat(coordinates)
            .setHTML(description)
            .addTo(map);
            
        map.flyTo({
            center: coordinates,
            pitch: 60,
            zoom:15,
            essential: true // this animation is considered essential with respect to prefers-reduced-motion
        });
    });

    // Change the cursor to a pointer when the mouse is over the places layer.
    map.on('mouseenter', 'osmw-launches', function() {
        map.getCanvas().style.cursor = 'pointer';
    });

    // Change it back to a pointer when it leaves.
    map.on('mouseleave', 'osmw-launches', function() {
        map.getCanvas().style.cursor = '';
    });
    forwardGeocoder();
});

// geolocation
const getLocation = (callback) => {
  navigator.geolocation.getCurrentPosition(function(position) {
    let startLon = position.coords.longitude;
    let startLat = position.coords.latitude;
    callback(startLon,startLat);
  });
};

// directions
const getRoute = (startLon,startLat,dest) => {
    console.log(dest);
  var dest = popup.getLngLat();
  var url = 'https://api.mapbox.com/directions/v5/mapbox/driving/' + startLon + ',' + startLat + ';' + dest.lng + ',' + dest.lat + '?geometries=geojson&overview=full&access_token=' + mapboxgl.accessToken;
  var req = new XMLHttpRequest();
  req.responseType = 'json';
  req.open('GET', url, true);
  req.onload  = function() {
    var data = req.response.routes[0];
    var route = data.geometry.coordinates;
    var geojsonRoute = {
      "type": "Feature",
      "properties": {},
      "geometry": {
        "type": "LineString",
        "coordinates": route
      }
    };
    var geojsonStart = {
      "type": "Feature",
      "properties": {},
      "geometry": {
        "type": "Point",
        "coordinates": [startLon,startLat]
      }
    };
    if (map.getSource('route')) {
      map.getSource('route').setData(geojsonRoute);
      map.getSource('start').setData(geojsonStart);
    } else {
      map.addLayer({
        "id": "start",
        "type": "symbol",
        "source": {
            "type": "geojson",
            "data": geojsonStart
        },
        "layout": {
            "icon-image": "circle-stroked-15",
            "text-field": "{title}",
            "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
            "text-offset": [0, 0.6],
            "text-anchor": "top"
        }
      },'osmw-launches');
      map.addLayer({
        "id": "route",
        "type": "line",
        "source": {
          "type": "geojson",
          "data": {
            "type": "Feature",
            "properties": {},
            "geometry": {
              "type": "LineString",
              "coordinates": route
            }
          }
        },
        "layout": {
          "line-join": "round",
          "line-cap": "round"
        },
        "paint": {
          "line-color": "rgba(0, 30, 84, 0.78)",
          "line-width": 8,
          "line-opacity": 0.75
        }
      },'waterway-label');
    };

    var coordinates = geojsonRoute.geometry.coordinates;

    // Pass the first coordinates in the LineString to `lngLatBounds` &
    // wrap each coordinate pair in `extend` to include them in the bounds
    // result. A variation of this technique could be applied to zooming
    // to the bounds of multiple Points or Polygon geomteries - it just
    // requires wrapping all the coordinates with the extend method.
    var bounds = coordinates.reduce(function(bounds, coord) {
        return bounds.extend(coord);
    }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));

    map.fitBounds(bounds, {
        padding: 20
    });

    popup.setLngLat([startLon,startLat])
      .setHTML('<span class="duration">' + Math.floor(data.duration/60) + ' min 🚗💨</span>');
    popup.addTo(map);
  };
  req.send();
};

// popup
var markerHeight = 20, markerRadius = 10, linearOffset = 25;
var popupOffsets = {
 'top': [0, 0],
 'top-left': [0,0],
 'top-right': [0,0],
 'bottom': [0, -markerHeight],
 'bottom-left': [linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
 'bottom-right': [-linearOffset, (markerHeight - markerRadius + linearOffset) * -1],
 'left': [markerRadius, (markerHeight - markerRadius) * -1],
 'right': [-markerRadius, (markerHeight - markerRadius) * -1]
};

var popup = new mapboxgl.Popup({
  offset: popupOffsets
});

document.getElementById('globe').addEventListener('click', function() {
  // Fly to a random location by offsetting the point -74.50, 40
  // by up to 5 degrees.
  map.flyTo({
    center: [-119.655,44.268],
    zoom: 6.5,
    pitch: 0,
    bearing: 0,
    essential: true // this animation is considered essential with respect to prefers-reduced-motion
  });
});


</script>

</body>
</html>
